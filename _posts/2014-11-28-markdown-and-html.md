---
layout: post
title: Transition from Assigned Apps to Capstone
---

The first apps I built were assigned projects meant to teach basic concepts through the process of developing replicas of such apps as Reddit and Wikipedia. With each project, the features I'd implement grew progressively complicated, while the curriculum-based instruction became more open-ended. The process was challenging, but my capstone was by far the most difficult.

#### Articulate the Problem
One thing I took for granted is my curriculum-based projects started with a clearly defined problem and solution. But for my capstone, I only had a general idea of the problem I wanted to solve; my girlfriend is a notary who specializes in real estate transactions and I wanted to build a tool for tracking and invoicing her jobs. It sounded simple enough, but I underestimated the process of both interpreting my girlfriend's professional needs, and then translating them into a series of clearly defined problems.

Part of the problem stemmed from the idiosyncrasies of a notary's workflow. To flesh out the details I had to conduct ongoing interviews with my girlfriend. These details were not always forthcoming because she had been a notary for years and had long since internalized many of the conditions that affected her workflow. I initially thought it would only take a couple of informal conversations but the process wound up being an ongoing venture, which forced me to continually update my definition of the problem.

#### Deciding on a Solution
With only a handful of projects under my belt, I kept defaulting to the assumption that there was a single best solution for any given problem. I learned that once you scale up from a simple app consisting of only few resources, the options for approaching a problem rapidly increases. There wasn't always a clear reason for solving a problem using STI, or a single polymorphic resource, or to use separate resources altogether. I suppose the takeaway was when in doubt, use a solution that you're comfortable with and matches the way you think about the problem.

I also thought I had to have every detail of the solution committed to paper before writing any code. But between the ongoing process of redefining the problem and the range of potential solutions, my mentor encouraged me not to become paralyzed by the uncertainty of implementation. Often just writing code to build some feature would illuminate the next step. If I ran into problems, I could always refactor.
